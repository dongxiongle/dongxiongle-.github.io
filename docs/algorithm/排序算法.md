## 冒泡排序
> 复杂度为O(n²)
1. 比较所有相邻的两个项，如果第一个比第二个大，则交换他们
```ts
function bubbleSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```
2. 上面的排序过程中，第一轮已经得到最大值，第二轮得到第二大的值，但第二轮依旧比较了最后一项，以此类推，以后的每一轮都会进行多余的比较。
```ts
function bubbleSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length; i++) {
    // 进行n轮比较后，就能获取n个最大的数，因此可以少比较已经确定的最大的数
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```
## 选择排序
> 选择排序是一种原址比较排序算法, 时间复杂度O(n²)
1. 找到数据结构中的最小值并放在第一位，然后找第二小的放在第二位，一次类推
```ts
function selectSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length - 1; i++) {
    for (let j = i+1; j < length; j++) {
      if (arr[i] > arr[j]) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```
## 插入排序
> 插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序。接着与第二项进行比较。排序小型数组时，此算法比选择排序和冒泡排序性能要好
```ts
function insertSort(arr: number[]) {
  const { length } = arr;
  let temp;
  for(let i = 1; i < length; i++) {
    let j = i;
    temp = arr[i];
    while(j > 0 && arr[j - 1]  > temp) {
      arr[j] = arr[j-1];
      j--;
    }
    arr[j] = temp;
  }
  return arr;
}
```
## 并归排序
> 并归排序是一种分治算法。将原始数组切分成较小的数组，直到每个小数组只有1个位置，接着将小数组并归成较大的数组，知道最后只有一个排序完毕的大数组。时间复杂度 O(nlog(n))
```ts
// 排序辅助函数
function merge7<T>(left: T[], right: T[]) {
  let i = 0;
  let j = 0;
  const result: T[] = [];
  // 排序
  while(i < left.length && j < right.length) {
    const a = left[i] < right[j] ? left[i++] : right[j++];
    result.push(a);
  }
  return result.concat(i < left.length ? left.slice(i) : right.slice(j));
}
// 将一个大数组分为多个小数组，并调用排序辅助函数
function mergeSort<T>(target: T[]) {
  let arr: T[] = target;
  const {length} = arr;
  if (length > 1) {
    // 分割数组
    const middle = Math.floor(length / 2);
    const left = mergeSort(arr.slice(0, middle));
    const right = mergeSort(arr.slice(middle, length))
    arr = merge7(left, right);
  }
  return arr;
}
```
## 快速排序
> 快速排序也是一种分治算法，将元素数组分为较小的数组 *（但并没有像并归排序那样拆分）*。时间复杂度为 O(nlog(n)),且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。
1. 从数组中选择一项作为主元（pivot）,一般取中间项
2. 划分操作。创建两个指针（left,right），左边的指向数组第一项，右边指向数组最后一项。移动left直到找到比主元大的值，接着，移动right直到找到比主元小的值，然后交换它们。重复这个过程，直到 *left > right*。这个过程会使得比主元小的值都排在主元的左侧，比主元大的值在主元右侧。
3. 对划分后的小数组（比主元小的值组成的子数组和比主元大的值组成的子数组）重复这个过程，直到数组完全排序。
```ts
/**
 * 快速排序入口
 * @param arr 待排序的数组
 */
function quickSort<T>(arr: T[]) {
  return quick(arr, 0, arr.length - 1);
}
/**
 * 排序递归函数
 * @param arr 待排序的数组
 * @param left 最左侧指针
 * @param right 最右侧指针
 * @returns 排序后的数组
 */
function quick<T>(arr: T[], left: number, right: number) {
  let index: number;
  if (arr.length > 1) {
    // 划分，获取指针
    index = partition(arr, left, right);
    // 对比主元小的子数组排序
    if (index - 1 > left) {
      quick(arr, left, index - 1);
    }
    // 对比主元大的子数组排序
    if (index < right) {
      quick(arr, index, right);
    }
  }
  return arr;
}
/**
 * 划分操作
 * @param arr 待排序数组
 * @param left 左侧指针
 * @param right 右侧指针
 * @returns 左侧指针
 */
function partition<T>(arr: T[], left: number, right: number) {
  const pivot = arr[Math.floor((left + right) / 2)];
  let i = left;
  let j = right;
  // 直到左侧指针超过右侧指针
  while (i <= j) {
    // 左侧，找到比主元大的值
    while (arr[i] < pivot) {
      i++;
    }
    // 右侧，找到比主元小的值
    while (arr[j] > pivot) {
      j--;
    }
    // 交换
    if (i <= j) {
      const temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
      i++;
      j--;
    }
  }
  return i;
}
```
## 计数排序
> 技术排序是一个分布式排序