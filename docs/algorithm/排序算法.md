## 冒泡排序
> 复杂度为O(n²)
1. 比较所有相邻的两个项，如果第一个比第二个大，则交换他们
```ts
function bubbleSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```
2. 上面的排序过程中，第一轮已经得到最大值，第二轮得到第二大的值，但第二轮依旧比较了最后一项，以此类推，以后的每一轮都会进行多余的比较。
```ts
function bubbleSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length; i++) {
    // 进行n轮比较后，就能获取n个最大的数，因此可以少比较已经确定的最大的数
    for (let j = 0; j < length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```
## 选择排序
> 选择排序是一种原址比较排序算法, 时间复杂度O(n²)
1. 找到数据结构中的最小值并放在第一位，然后找第二小的放在第二位，一次类推
```ts
function selectSort(arr: number[]) {
  const { length } = arr;
  for (let i = 0; i < length - 1; i++) {
    for (let j = i+1; j < length; j++) {
      if (arr[i] > arr[j]) {
        let temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }
    }
  }
  return arr;
}
```
## 插入排序
> 插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序。接着与第二项进行比较。排序小型数组时，此算法比选择排序和冒泡排序性能要好
```ts
function insertSort(arr: number[]) {
  const { length } = arr;
  let temp;
  for(let i = 1; i < length; i++) {
    let j = i;
    temp = arr[i];
    while(j > 0 && arr[j - 1]  > temp) {
      arr[j] = arr[j-1];
      j--;
    }
    arr[j] = temp;
  }
  return arr;
}
```
## 并归排序
> 并归排序是一种分治算法。将原始数组切分成较小的数组，直到每个小数组只有1个位置，接着将小数组并归成较大的数组，知道最后只有一个排序完毕的大数组。时间复杂度 O(nlog(n))
