## 分治
> 将一个问题分成多个和原问题相似的小问题(相互独立)，递归解决小问题，再将解决方式合并以解决原来的问题
1. 分解原问题为多个子问题
2. 解决子问题，用返回解决子问题的方式递归算法
3. 组合这些子问题的解决方法，得到原问题的解
### 使用分治算法实现二分搜索
```ts
function binarySearch9<T>(arr: T[], value: T) {
  const sortArr = arr;
  const start = 0;
  const end = sortArr.length - 1;
  return binarySearchRecursive(sortArr, value, start, end);
}
function binarySearchRecursive<T>(
  arr: T[],
  value: T,
  start: number,
  end: number
): Function | number {
  if (start <= end) {
    const middle = Math.floor((start + end) / 2);
    const element = arr[middle];
    if (element < value) {
      return binarySearchRecursive(arr, value, middle + 1, end);
    } else if (element > value) {
      return binarySearchRecursive(arr, value, start, middle - 1);
    } else {
      return middle;
    }
  }
  return -1;
}
```
## 动态规划
> 动态规划是一种将复杂问题分解成更小的子问题(相互依赖)来解决的优化技术
1. 定义子问题
2. 实现要反复执行来解决子问题的部分
3. 识别并求解出基线条件

### 最少硬币找零
> 给出面额为 *d1,d2...dn* 的一定数量的硬币和要找零的钱数n，找到所需的最小的硬币个数。